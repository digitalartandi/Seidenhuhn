<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>H√ºhnerhof‚ÄëH√ºpfer</title>
<link rel="manifest" href="manifest.webmanifest"/>
<meta name="theme-color" content="#c5e1a5"/>
<style>
  :root{ --ink:#1d2b1d; --brand:#43a047; --bg:#e8f5e9; --glass:rgba(255,255,255,.9); }
  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html, body{ height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  #app{ position:fixed; inset:0; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); display:grid; grid-template-rows:auto 1fr auto; gap:0; }
  header{ display:flex; gap:.5rem; align-items:center; padding:.35rem .65rem; }
  .hud{ display:flex; gap:.4rem; font-weight:800; flex-wrap:wrap; }
  .pill{ background:var(--glass); border:2px solid #cde9d1; border-radius:999px; padding:.22rem .55rem; box-shadow:0 4px 16px rgba(0,0,0,.05); }

  /* FULL BLEED meadow background without border radius or inner padding */
  #playArea{ position:relative; overflow:hidden; border:none; border-radius:0; background:url('meadow.webp') center/cover no-repeat; display:grid; place-items:center; }
  .canvasFrame{ position:relative; width:100%; height:100%; display:grid; place-items:center; }
  canvas{ display:block; max-width:100%; max-height:100%; touch-action:none; image-rendering:auto;
          background:linear-gradient(180deg,#f8fff9 0%, #eef7f0 100%); border:1px solid #d6ead7; border-radius:12px; box-shadow:0 8px 20px rgba(0,0,0,.05); }

  /* Wood nav sits tight below, no extra gap */
  #uiBar{ position:relative; border-top:2px solid #caa27a; background:url('wood.webp') center/cover no-repeat; display:flex; justify-content:center; align-items:center; padding:.2rem 0 calc(.3rem + env(safe-area-inset-bottom)); }
  #uiBar::before{ content:''; position:absolute; inset:0; background:rgba(255,255,255,.14); pointer-events:none; }

  .pad{ position:relative; z-index:1; display:grid; grid-template-columns:46px 46px 46px; grid-template-rows:46px 46px 46px; gap:.22rem; }
  .pad button{ width:46px; height:46px; border-radius:12px; border:none; background:#fff; border:2px solid #d7efe0; box-shadow:0 3px 0 #c7e5d3; font-size:1rem; }
  .pad .empty{ visibility:hidden; }

  #startFS{ position:fixed; inset:0; z-index:9999; display:flex; align-items:flex-end; justify-content:center; background:#000; }
  #startFS::before{ content:''; position:absolute; inset:0; background:url('cover.webp') center/cover no-repeat; }
  #play{ position:relative; margin: 1.2rem 0 calc(1.2rem + env(safe-area-inset-bottom)); padding:1rem 2rem; font-size:1.4rem; border:none; border-radius:18px; background:#43a047; color:#fff; box-shadow:0 10px 20px rgba(67,160,71,.35), 0 6px 0 #2e7d32; }
  #play:active{ transform:translateY(2px); box-shadow:0 4px 0 #2e7d32; }

  #over{ position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:9000; background:rgba(0,0,0,.35); }
  .card{ background:#fff; border:2px solid #d6ead7; border-radius:16px; padding:1rem; width:min(90vw,420px); text-align:center; box-shadow:0 16px 40px rgba(0,0,0,.18); }
  .card h3{ margin:.3rem 0 .8rem; }
  .row{ display:flex; gap:.6rem; justify-content:center; }
  .btn{ border:none; border-radius:14px; padding:.7rem 1.1rem; font-weight:800; }
  .btn.primary{ background:#43a047; color:#fff; }
  .btn.ghost{ background:#fff; border:2px solid #cfe7d3; }

  footer{ padding: .1rem .65rem .45rem; text-align:center; font-size:.85rem; color:#4f6b50; }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="hud">
      <div class="pill">Punkte: <span id="score">0</span></div>
      <div class="pill">Level: <span id="level">1</span></div>
      <div class="pill">Highscore: <span id="hi">0</span></div>
    </div>
  </header>

  <section id="playArea">
    <div class="canvasFrame">
      <canvas id="game" width="720" height="1280" aria-label="Seidenhuhn sammelt K√∂rner und W√ºrmer"></canvas>
    </div>
  </section>

  <div id="uiBar">
    <div class="pad" id="pad" aria-label="Richtungstasten">
      <div class="empty"></div><button data-d="0,-1">‚¨ÜÔ∏è</button><div class="empty"></div>
      <button data-d="-1,0">‚¨ÖÔ∏è</button><div class="empty"></div><button data-d="1,0">‚û°Ô∏è</button>
      <div class="empty"></div><button data-d="0,1">‚¨áÔ∏è</button><div class="empty"></div>
    </div>
  </div>

  <footer>F√ºr Kinder ¬∑ Offline spielbar ¬∑ v1.11.0</footer>
</div>

<div id="startFS">
  <button id="play" aria-label="Spiel starten">‚ñ∂Ô∏è Start</button>
</div>

<div id="over">
  <div class="card">
    <h3>Spiel vorbei üí´</h3>
    <p><strong>Punkte:</strong> <span id="fScore">0</span> ¬∑ <strong>Highscore:</strong> <span id="fHi">0</span></p>
    <div class="row">
      <button class="btn primary" id="again">üîÅ Nochmal</button>
      <button class="btn ghost" id="menu">üèÅ Start</button>
    </div>
  </div>
</div>

<script>
(function(){ 'use strict';
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha:false});
  const playArea = document.getElementById('playArea');
  const frame = document.querySelector('.canvasFrame');

  function sizeCanvas(pxW, pxH){
    canvas.style.width = pxW + 'px';
    canvas.style.height = pxH + 'px';
    canvas.width = Math.round(pxW * dpr);
    canvas.height = Math.round(pxH * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
  }

  // --- Smooth movement state ---
  const state = {
    grid: 36, cols: 18, rows: 26,
    hen: {x:4,y:10},      // logical cell
    prevHen: {x:4,y:10},  // last cell for interpolation
    dir: {x:1,y:0}, next: {x:1,y:0},
    items: [], // {x,y,type:'grain'|'worm'|'gold'}
    score: 0, level: 1,
    speed: 4.8,   // cells per second (smooth)
    last: 0,      // last timestamp
    mover: 0,     // progress within current cell [0..1]
    running: false,
    hi: parseInt(localStorage.getItem('hh_hi')||'0',10)
  };
  document.getElementById('hi').textContent = state.hi;

  function innerSize(el){ const cs=getComputedStyle(el); return {w: el.clientWidth - parseFloat(cs.paddingLeft||0) - parseFloat(cs.paddingRight||0), h: el.clientHeight - parseFloat(cs.paddingTop||0) - parseFloat(cs.paddingBottom||0)}; }

  function fit(){
    const {w,h} = innerSize(playArea);
    const {w:fw,h:fh} = innerSize(frame);
    const W = Math.min(w, fw), H = Math.min(h, fh);
    const targetRows = 26;
    let cell = Math.max(28, Math.floor(H / targetRows));
    let cols = Math.max(12, Math.floor(W / cell));
    let rows = Math.max(16, Math.floor(H / cell));
    cell = Math.floor(Math.min(W/cols, H/rows));
    sizeCanvas(cols*cell, rows*cell);
    state.grid = cell; state.cols = cols; state.rows = rows;
    state.hen.x = Math.min(state.hen.x, cols-1);
    state.hen.y = Math.min(state.hen.y, rows-1);
    draw(0);
  }
  new ResizeObserver(fit).observe(playArea);
  window.addEventListener('orientationchange', ()=> setTimeout(fit,0));

  const henImg = new Image(); henImg.src = 'hen.webp'; // repo asset

  function reset(){
    state.dir={x:1,y:0}; state.next={x:1,y:0};
    const cx=Math.floor(state.cols/2)-1, cy=Math.floor(state.rows/2);
    state.hen={x:cx,y:cy}; state.prevHen={x:cx,y:cy};
    state.items = Array.from({length:4}, spawnItem);
    state.score=0; state.level=1; state.speed=4.8;
    document.getElementById('score').textContent=0;
    document.getElementById('level').textContent=1;
  }
  function spawnItem(){
    const r=Math.random(); const type = r<0.65?'grain':(r<0.90?'worm':'gold');
    let x,y,tries=0;
    do{
      x=Math.floor(Math.random()*state.cols);
      y=Math.floor(Math.random()*state.rows);
      tries++; if(tries>300) break;
    }while((x===state.hen.x && y===state.hen.y) || state.items.some(i=>i && i.x===x && i.y===y));
    return {x,y,type};
  }

  function setDir(x,y){
    // allow quick double turns but avoid 180¬∞ within same segment
    if(x===-state.dir.x && y===-state.dir.y) return;
    state.next={x,y};
  }

  // --- Game step with smooth interpolation ---
  function advanceCell(){
    state.prevHen = {x: state.hen.x, y: state.hen.y};
    state.dir = state.next;
    const nx = state.hen.x + state.dir.x;
    const ny = state.hen.y + state.dir.y;
    if(nx<0 || ny<0 || nx>=state.cols || ny>=state.rows){ gameOver(); return false; }
    state.hen = {x:nx, y:ny};
    // eat
    for(let i=0;i<state.items.length;i++){
      const it=state.items[i];
      if(it && it.x===nx && it.y===ny){
        let add=10; if(it.type==='worm') add=25; if(it.type==='gold') add=50;
        state.score+=add; document.getElementById('score').textContent=state.score;
        if(state.score>state.hi){ state.hi=state.score; localStorage.setItem('hh_hi', String(state.hi)); document.getElementById('hi').textContent=state.hi; }
        if(state.score%50===0){ state.level++; document.getElementById('level').textContent=state.level; state.speed = Math.min(9, state.speed + 0.35); }
        state.items[i]=spawnItem();
      }
    }
    return true;
  }

  function draw(interp){
    const g=state.grid; if(!g) return;
    // canvas grid
    ctx.fillStyle='#f3fbf5'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle='rgba(120,170,135,.25)'; ctx.lineWidth=1;
    for(let x=0;x<=state.cols;x++){ ctx.beginPath(); ctx.moveTo(x*g+.5,0); ctx.lineTo(x*g+.5,canvas.height); ctx.stroke(); }
    for(let y=0;y<=state.rows;y++){ ctx.beginPath(); ctx.moveTo(0,y*g+.5); ctx.lineTo(canvas.width,y*g+.5); ctx.stroke(); }
    // items
    state.items.forEach((it,i)=> drawItem(it,i));
    // hen with interpolation
    const rx = state.prevHen.x + (state.hen.x - state.prevHen.x) * interp;
    const ry = state.prevHen.y + (state.hen.y - state.prevHen.y) * interp;
    drawHen(rx, ry);
  }

  function drawItem(it, idx){
    const g=state.grid, cx=it.x*g+g/2, cy=it.y*g+g/2;
    const bob=Math.sin(performance.now()/520+idx)*g*0.05;
    ctx.save(); ctx.translate(cx, cy+bob);
    if(it.type==='worm'){
      ctx.lineWidth=Math.max(2,g*0.08); ctx.strokeStyle='#d16b5e';
      ctx.beginPath(); ctx.moveTo(-g*0.18,0);
      ctx.quadraticCurveTo(-g*0.05,-g*0.12,g*0.1,-g*0.02);
      ctx.quadraticCurveTo(g*0.22,g*0.08,g*0.18,g*0.12); ctx.stroke();
      ctx.beginPath(); ctx.arc(g*0.18,g*0.12,g*0.04,0,Math.PI*2); ctx.fillStyle='#d16b5e'; ctx.fill();
    } else if(it.type==='gold'){
      ctx.fillStyle='#ffd54f'; ctx.strokeStyle='#b38a00';
      ctx.beginPath(); ctx.ellipse(0,0,g*0.24,g*0.18,Math.PI/8,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.stroke();
      ctx.fillStyle='rgba(255,255,255,.85)'; ctx.beginPath(); ctx.moveTo(g*0.06,-g*0.12); ctx.lineTo(g*0.16,-g*0.12); ctx.lineTo(g*0.08,-g*0.02); ctx.closePath(); ctx.fill();
    } else {
      ctx.fillStyle='#ffca28'; ctx.strokeStyle='#b28900';
      ctx.beginPath(); ctx.ellipse(0,0,g*0.22,g*0.16,Math.PI/7,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.stroke();
    }
    ctx.restore();
  }

  function drawHen(x,y){
    const g=state.grid; const size=Math.min(g*1.7, g*1.2+20);
    const px=x*g+(g-size)/2, py=y*g+(g-size)/2;
    const img=window.__hen||(window.__hen=new Image()); if(!img.src) img.src='hen.webp';
    if(img.complete){ ctx.save(); ctx.shadowColor='rgba(0,0,0,.18)'; ctx.shadowBlur=8; ctx.drawImage(img, px, py, size, size); ctx.restore(); }
    else { img.onload=()=>draw(1); ctx.fillStyle='#fff'; ctx.fillRect(px,py,size,size); }
  }

  // --- Main loop (smooth) ---
  function loop(ts){
    if(!state.running) return;
    if(!state.last) state.last=ts;
    const dt=(ts-state.last)/1000; // seconds
    state.last=ts;
    // advance mover by speed*dt cells; when >=1, step cell
    state.mover += state.speed * dt;
    while(state.mover >= 1){
      if(!advanceCell()) return; // game over
      state.mover -= 1;
    }
    // interpolate 0..1
    draw(state.mover);
    requestAnimationFrame(loop);
  }

  function gameOver(){
    state.running=false;
    document.getElementById('fScore').textContent=state.score;
    document.getElementById('fHi').textContent=state.hi;
    document.getElementById('over').style.display='flex';
  }

  // --- Start & Inputs ---
  document.getElementById('again').addEventListener('click', ()=>{
    document.getElementById('over').style.display='none';
    reset(); fit(); state.running=true; state.last=0; state.mover=0; requestAnimationFrame(loop);
  });
  document.getElementById('menu').addEventListener('click', ()=>{
    document.getElementById('over').style.display='none';
    document.getElementById('startFS').style.display='flex';
  });
  document.getElementById('play').addEventListener('pointerdown', ()=>{
    document.getElementById('startFS').style.display='none';
    reset(); fit(); state.running=true; state.last=0; state.mover=0; requestAnimationFrame(loop);
  }, {passive:true});

  // On-screen pad: use pointerdown for immediate response (no click delay)
  document.getElementById('pad').addEventListener('pointerdown', (e)=>{
    const b=e.target.closest('button'); if(!b) return;
    const [x,y]=b.getAttribute('data-d').split(',').map(Number);
    setDir(x,y);
  });

  // Swipes: detect on touchmove for quicker reaction
  let s=null;
  playArea.addEventListener('touchstart',(e)=>{ const t=e.touches[0]; s={x:t.clientX,y:t.clientY}; },{passive:true});
  playArea.addEventListener('touchmove',(e)=>{ if(!s) return; const t=e.touches[0]; const dx=t.clientX-s.x, dy=t.clientY-s.y; const ax=Math.abs(dx), ay=Math.abs(dy);
    if(Math.max(ax,ay)>18){ if(ax>ay) setDir(Math.sign(dx),0); else setDir(0,Math.sign(dy)); s=null; } },{passive:true});
  playArea.addEventListener('touchend',()=>{ s=null; },{passive:true});

  // Keyboard
  window.addEventListener('keydown',(e)=>{
    if(e.key==='ArrowUp'||e.key==='w') setDir(0,-1);
    else if(e.key==='ArrowDown'||e.key==='s') setDir(0,1);
    else if(e.key==='ArrowLeft'||e.key==='a') setDir(-1,0);
    else if(e.key==='ArrowRight'||e.key==='d') setDir(1,0);
  });

  fit();
})();
</script>
</body>
</html>
