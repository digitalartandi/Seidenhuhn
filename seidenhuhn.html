<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"/>
<title>Hühnerhof‑Hüpfer</title>
<link rel="manifest" href="manifest.webmanifest"/>
<meta name="theme-color" content="#c5e1a5"/>
<style>
  :root{ --ink:#1d2b1d; --brand:#43a047; --bg:#e8f5e9; --panel:#ffffff; --glass:rgba(255,255,255,.85); }
  *{ box-sizing:border-box; -webkit-tap-highlight-color: transparent; }
  html, body{ height:100%; margin:0; background:var(--bg); color:var(--ink); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
  #app{ position:fixed; inset:0; padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); display:grid; grid-template-rows:auto 1fr auto; gap:.4rem; }
  header{ display:flex; gap:.6rem; align-items:center; padding:.45rem .75rem; }
  .hud{ display:flex; gap:.5rem; font-weight:800; }
  .pill{ background:var(--glass); border:2px solid #cde9d1; border-radius:999px; padding:.25rem .6rem; box-shadow:0 4px 16px rgba(0,0,0,.05); }
  #playArea{ position:relative; overflow:hidden; border-radius:16px; border:2px solid #cde9d1; box-shadow:0 10px 30px rgba(0,0,0,.06); background:radial-gradient(circle at 50% 20%, #ffffff 0%, #f5fcff 40%, #e9f7ff 100%); }
  #uiBar{ position:relative; background:var(--glass); border-top:2px solid #cde9d1; backdrop-filter:saturate(140%) blur(6px); display:flex; justify-content:center; align-items:center; padding: .5rem 0 calc(.5rem + env(safe-area-inset-bottom)); }
  .pad{ display:grid; grid-template-columns:56px 56px 56px; grid-template-rows:56px 56px 56px; gap:.5rem; }
  .pad button{ width:56px; height:56px; border-radius:16px; border:none; background:#fff; border:2px solid #d7efe0; box-shadow:0 4px 0 #c7e5d3; font-size:1.1rem; }
  .pad .empty{ visibility:hidden; }
  canvas{ display:block; width:100%; height:100%; touch-action:none; }
  /* Start */
  #start{ position:absolute; inset:0; display:flex; align-items:flex-end; justify-content:center; z-index:9999; }
  #start::before{ content:''; position:absolute; inset:0; background:url('cover.webp') center/cover no-repeat; }
  #play{ position:relative; margin: 1rem 0; padding:1rem 2rem; font-size:1.4rem; border:none; border-radius:18px; background:var(--brand); color:#fff; box-shadow:0 10px 20px rgba(67,160,71,.35), 0 6px 0 #2e7d32; }
  #play:active{ transform:translateY(2px); box-shadow:0 4px 0 #2e7d32; }
  footer{ padding: .2rem .75rem .6rem; text-align:center; font-size:.85rem; color:#4f6b50; }
</style>
</head>
<body>
<div id="app">
  <header>
    <div class="hud">
      <div class="pill">Punkte: <span id="score">0</span></div>
      <div class="pill">Level: <span id="level">1</span></div>
    </div>
  </header>

  <section id="playArea">
    <canvas id="game" width="720" height="1280" aria-label="Seidenhuhn sammelt Körner"></canvas>
    <div id="start">
      <button id="play" aria-label="Spiel starten">▶️ Start</button>
    </div>
  </section>

  <div id="uiBar">
    <div class="pad" id="pad" aria-label="Richtungstasten">
      <div class="empty"></div><button data-d="0,-1">⬆️</button><div class="empty"></div>
      <button data-d="-1,0">⬅️</button><div class="empty"></div><button data-d="1,0">➡️</button>
      <div class="empty"></div><button data-d="0,1">⬇️</button><div class="empty"></div>
    </div>
  </div>

  <footer>Für Kinder · Offline spielbar</footer>
</div>

<script>
(function(){ 'use strict';
  // Layout: compute canvas size so it never sits under the controls bar
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', {alpha:false});
  const playArea = document.getElementById('playArea');
  const uiBar = document.getElementById('uiBar');

  const state = {
    grid: 32, cols: 14, rows: 22, // weniger Zellen -> größere Zellen
    hen: {x:4,y:10},
    dir: {x:1,y:0},
    next: {x:1,y:0},
    foods: [],
    score: 0,
    level: 1,
    tick: 220, // noch etwas langsamer
    last: 0, acc: 0,
    running: false
  };

  const henImg = new Image(); henImg.src = 'hen.webp';

  function fit(){
    // Reserve space for UI bar (already separate element), so canvas fills playArea minus borders
    const w = playArea.clientWidth;
    const h = playArea.clientHeight;
    const cell = Math.floor(Math.min(w/state.cols, h/state.rows));
    canvas.width = state.cols * cell;
    canvas.height = state.rows * cell;
    state.grid = cell;
    draw();
  }
  new ResizeObserver(fit).observe(playArea);
  window.addEventListener('orientationchange', ()=> setTimeout(fit,0));

  function reset(){
    state.hen = {x: Math.floor(state.cols/2)-1, y: Math.floor(state.rows/2)};
    state.dir = {x:1,y:0}; state.next = {x:1,y:0};
    state.foods = Array.from({length:3}, randomFree);
    state.score=0; state.level=1; state.tick=220;
    document.getElementById('score').textContent=0;
    document.getElementById('level').textContent=1;
  }
  function randomFree(){
    let x,y,tries=0;
    do{ x=Math.floor(Math.random()*state.cols); y=Math.floor(Math.random()*state.rows); tries++; if(tries>200) break; }
    while((x===state.hen.x && y===state.hen.y) || state.foods.some(f=>f && f.x===x && f.y===y));
    return {x,y};
  }
  function setDir(x,y){ if(x===-state.dir.x && y===-state.dir.y) return; state.next={x,y}; }

  function step(){
    state.dir = state.next;
    const nx = state.hen.x + state.dir.x;
    const ny = state.hen.y + state.dir.y;
    // Game over at border
    if(nx<0 || ny<0 || nx>=state.cols || ny>=state.rows) return gameOver();
    state.hen = {x:nx,y:ny};
    // Eat
    for(let i=0;i<state.foods.length;i++){
      const f = state.foods[i];
      if(f && f.x===nx && f.y===ny){
        state.foods[i] = randomFree();
        state.score += 10; document.getElementById('score').textContent=state.score;
        if(state.score % 50 === 0){ state.level++; document.getElementById('level').textContent=state.level; state.tick = Math.max(110, state.tick-12); }
      }
    }
  }

  function draw(){
    const g=state.grid; if(!g) return;
    // Background grid (farm tone)
    ctx.fillStyle='#eef7f0'; ctx.fillRect(0,0,canvas.width,canvas.height);
    ctx.strokeStyle='rgba(120,170,135,.35)'; ctx.lineWidth=1;
    for(let x=0;x<=state.cols;x++){ ctx.beginPath(); ctx.moveTo(x*g+.5,0); ctx.lineTo(x*g+.5,canvas.height); ctx.stroke(); }
    for(let y=0;y<=state.rows;y++){ ctx.beginPath(); ctx.moveTo(0,y*g+.5); ctx.lineTo(canvas.width,y*g+.5); ctx.stroke(); }
    // foods
    state.foods.forEach((f,i)=> drawGrain(f.x,f.y,i));
    // hen bigger than a cell for clarity (clamped)
    drawHen(state.hen.x, state.hen.y);
  }

  function drawGrain(x,y,i){
    const g=state.grid, cx=x*g+g/2, cy=y*g+g/2;
    const bob = Math.sin(performance.now()/500 + i) * g*0.05;
    ctx.save(); ctx.translate(cx, cy + bob);
    ctx.fillStyle='#ffca28'; ctx.strokeStyle='#b28900';
    ctx.beginPath(); ctx.ellipse(0,0,g*0.22,g*0.16,Math.PI/7,0,Math.PI*2); ctx.fill(); ctx.lineWidth=2; ctx.stroke();
    ctx.restore();
  }

  function drawHen(x,y){
    const g=state.grid; const pad=g*0.02; // minimal padding
    const size = Math.min(g*1.4, g*1.2 + 12); // größer als ein Feld, aber begrenzt
    const px = x*g + (g - size)/2;
    const py = y*g + (g - size)/2;
    if(henImg.complete) ctx.drawImage(henImg, px, py, size, size);
    else { ctx.fillStyle='#fff'; ctx.fillRect(px,py,size,size); }
  }

  function loop(ts){
    if(!state.running) return;
    if(!state.last) state.last=ts; const dt=ts-state.last; state.last=ts; state.acc+=dt;
    while(state.acc>=state.tick){ step(); state.acc-=state.tick; }
    draw(); requestAnimationFrame(loop);
  }

  function gameOver(){
    state.running=false;
    document.getElementById('start').style.display='flex';
  }

  // Start & controls
  document.getElementById('play').addEventListener('click', ()=>{
    document.getElementById('start').style.display='none';
    reset(); fit(); state.running=true; state.last=0; state.acc=0; requestAnimationFrame(loop);
  });

  // On-screen pad
  document.getElementById('pad').addEventListener('click', (e)=>{
    const b = e.target.closest('button'); if(!b) return;
    const [x,y] = b.getAttribute('data-d').split(',').map(Number);
    setDir(x,y);
  });

  // Swipe
  let s=null;
  playArea.addEventListener('touchstart', (e)=>{ const t=e.touches[0]; s={x:t.clientX, y:t.clientY}; }, {passive:true});
  playArea.addEventListener('touchend', (e)=>{
    if(!s) return; const t=e.changedTouches[0];
    const dx=t.clientX-s.x, dy=t.clientY-s.y; const ax=Math.abs(dx), ay=Math.abs(dy);
    if(Math.max(ax,ay) > 24){ if(ax>ay) setDir(Math.sign(dx),0); else setDir(0,Math.sign(dy)); }
    s=null;
  }, {passive:true});

  // Keyboard
  window.addEventListener('keydown', (e)=>{
    if(e.key==='ArrowUp'||e.key==='w') setDir(0,-1);
    else if(e.key==='ArrowDown'||e.key==='s') setDir(0,1);
    else if(e.key==='ArrowLeft'||e.key==='a') setDir(-1,0);
    else if(e.key==='ArrowRight'||e.key==='d') setDir(1,0);
  });

  // initial
  fit();
})();
</script>
</body>
</html>
